<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Snake Game</title> <!-- Changed title to 'Snake Game' -->
    <!-- Load Tailwind CSS for utility classes -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom CSS for the Game Board and Grid Pattern */
        :root {
            --game-board-color: #a2d149; /* Light green board */
            --grid-line-color: rgba(0, 0, 0, 0.08);
            --snake-color: #4a90e2; /* Blue snake */
            --apple-color: #e74c3c; /* Red apple */
            --tile-size: 20px;
            --grid-size: 20;
            --board-dimension: calc(var(--tile-size) * var(--grid-size));
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: #2c3e50; /* Dark background */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 20px;
        }

        .game-container {
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5);
            border-radius: 12px;
            overflow: hidden; /* important to contain the canvas shadow */
        }

        #gameCanvas {
            width: var(--board-dimension);
            height: var(--board-dimension);
            background-color: var(--game-board-color);
            /* Create the subtle grid pattern using repeating linear gradients */
            background-image: 
                repeating-linear-gradient(0deg, var(--grid-line-color), var(--grid-line-color) 1px, transparent 1px, transparent calc(var(--tile-size) - 1px)),
                repeating-linear-gradient(90deg, var(--grid-line-color), var(--grid-line-color) 1px, transparent 1px, transparent calc(var(--tile-size) - 1px));
            background-size: var(--tile-size) var(--tile-size);
            border: 4px solid #34495e; /* Dark border for definition */
            display: block;
        }

        .snake-segment {
            border-radius: 5px; /* Rounded corners for the snake segments */
        }

        .message-box {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            z-index: 10;
        }

        .restart-button {
            background-color: #f39c12;
            color: white;
            padding: 10px 20px;
            margin-top: 20px;
            border-radius: 8px;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.2s;
            border: none;
        }

        .restart-button:hover {
            background-color: #e67e22;
        }

        @keyframes pulse {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.1); opacity: 0.8; }
            100% { transform: scale(1); opacity: 1; }
        }

        .apple-pulse {
            animation: pulse 0.5s ease-out;
        }
    </style>
</head>
<body class="selection:bg-yellow-400 selection:text-black">

    <div class="game-container w-full max-w-sm flex flex-col items-center p-4 bg-gray-800 rounded-xl">
        
        <!-- Score Display -->
        <div id="score" class="text-white text-xl font-bold mb-4 flex items-center justify-between w-full max-w-[var(--board-dimension)]">
            <span class="p-2 bg-gray-700 rounded-lg shadow-md">
                üçé Score: 0
            </span>
            <span id="game-status" class="text-yellow-400 text-sm italic"></span>
        </div>

        <!-- Canvas and Game Overlay -->
        <div id="canvas-wrapper" class="relative">
            <canvas id="gameCanvas"></canvas>

            <!-- Game Start/Over Message Box (Hidden by default, shown when needed) -->
            <div id="messageBox" class="message-box hidden rounded-lg">
                <!-- Content will be set by JavaScript -->
            </div>
        </div>

    </div>
    
    <!-- Audio Elements -->
    <audio id="bgMusic" src="https://www.soundjay.com/misc/sounds/wind-chime-3.mp3" preload="auto" loop></audio>
    <audio id="eatSound" src="https://www.soundjay.com/misc/sounds/magic-chime-01.mp3" preload="auto"></audio>
    <!-- Game Over Sound (NEW) -->
    <audio id="failSound" src="https://www.soundjay.com/misc/sounds/fail-trumpet-1.mp3" preload="auto"></audio>

    <script>
        // --- Game Constants and Setup ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreDisplay = document.getElementById('score');
        const messageBox = document.getElementById('messageBox');
        const gameStatus = document.getElementById('game-status');
        
        // Audio elements
        const bgMusic = document.getElementById('bgMusic');
        const eatSound = document.getElementById('eatSound');
        const failSound = document.getElementById('failSound'); // NEW fail sound

        const TILE_SIZE = 20; // Pixel size of each tile
        const GRID_SIZE = 20; // Number of tiles in one dimension (20x20 grid)
        const GAME_SPEED = 100; // Milliseconds per move step
        
        // Set canvas dimensions based on constants
        canvas.width = TILE_SIZE * GRID_SIZE;
        canvas.height = TILE_SIZE * GRID_SIZE;

        // Colors
        const SNAKE_COLOR = 'var(--snake-color)';
        const APPLE_COLOR = 'var(--apple-color)';

        // Game state variables
        let snake;
        let food;
        let direction;
        let score;
        let isGameOver;
        let isGamePaused; // NEW: Added paused state for start screen
        let lastMoveTime;
        let nextDirection; // Buffer for direction changes
        let gameLoopId;

        // --- Utility Functions ---
        
        /**
         * Robustly attempts to play an audio element, handling auto-play policy rejections.
         * Sets volume to 1.0 for maximum volume.
         * @param {HTMLAudioElement} audioElement The audio element to play.
         */
        function playAudio(audioElement) {
            audioElement.volume = 1.0; // Ensure 100% volume
            audioElement.currentTime = 0; // Rewind before playing (important for effects)
            audioElement.play().catch(error => {
                // Audio playback error, usually due to browser policy.
                // We log it, but the fix relies on the user interaction trigger.
                console.error("Audio playback blocked:", error);
            });
        }

        /**
         * Converts grid coordinates (x, y) to canvas pixel coordinates.
         * @param {number} p Grid position.
         * @returns {number} Canvas pixel position.
         */
        const toPixels = (p) => p * TILE_SIZE;

        /**
         * Generates a random, unoccupied grid coordinate for the food.
         */
        function generateFood() {
            let newFood;
            do {
                newFood = {
                    x: Math.floor(Math.random() * GRID_SIZE),
                    y: Math.floor(Math.random() * GRID_SIZE)
                };
            } while (snake.some(segment => segment.x === newFood.x && segment.y === newFood.y));
            food = newFood;
        }

        /**
         * Initializes the game state variables.
         */
        function resetGameLogic() {
            // Initial snake position (center-ish)
            snake = [
                { x: Math.floor(GRID_SIZE / 2) + 2, y: Math.floor(GRID_SIZE / 2) },
                { x: Math.floor(GRID_SIZE / 2) + 1, y: Math.floor(GRID_SIZE / 2) },
                { x: Math.floor(GRID_SIZE / 2), y: Math.floor(GRID_SIZE / 2) }
            ];
            direction = { x: 1, y: 0 }; // Start moving right
            nextDirection = { x: 1, y: 0 };
            score = 0;
            isGameOver = false;
            isGamePaused = true;
            lastMoveTime = performance.now();
            scoreDisplay.children[0].textContent = `üçé Score: ${score}`;

            generateFood();
            draw(); // Draw initial state
        }
        
        /**
         * Draws the current game state (snake and food) on the canvas.
         */
        function draw() {
            // Clear the canvas area
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw Food (Apple)
            ctx.fillStyle = APPLE_COLOR;
            ctx.beginPath();
            const foodX = toPixels(food.x);
            const foodY = toPixels(food.y);
            const radius = 4; // Corner radius for the apple
            
            ctx.moveTo(foodX + radius, foodY);
            ctx.lineTo(foodX + TILE_SIZE - radius, foodY);
            ctx.arc(foodX + TILE_SIZE - radius, foodY + radius, radius, 1.5 * Math.PI, 0);
            ctx.lineTo(foodX + TILE_SIZE, foodY + TILE_SIZE - radius);
            ctx.arc(foodX + TILE_SIZE - radius, foodY + TILE_SIZE - radius, radius, 0, 0.5 * Math.PI);
            ctx.lineTo(foodX + radius, foodY + TILE_SIZE);
            ctx.arc(foodX + radius, foodY + TILE_SIZE - radius, radius, 0.5 * Math.PI, Math.PI);
            ctx.lineTo(foodX, foodY + radius);
            ctx.arc(foodX + radius, foodY + radius, radius, Math.PI, 1.5 * Math.PI);
            ctx.fill();


            // Draw Snake
            snake.forEach((segment, index) => {
                // Determine color: slightly darker head
                ctx.fillStyle = index === 0 ? '#3c79c8' : SNAKE_COLOR; 
                
                // Draw a rounded rectangle for each segment
                const x = toPixels(segment.x);
                const y = toPixels(segment.y);
                const radius = 3; // Corner radius for segments

                ctx.beginPath();
                ctx.moveTo(x + radius, y);
                ctx.lineTo(x + TILE_SIZE - radius, y);
                ctx.arc(x + TILE_SIZE - radius, y + radius, radius, 1.5 * Math.PI, 0);
                ctx.lineTo(x + TILE_SIZE, y + TILE_SIZE - radius);
                ctx.arc(x + TILE_SIZE - radius, y + TILE_SIZE - radius, radius, 0, 0.5 * Math.PI);
                ctx.lineTo(x + radius, y + TILE_SIZE);
                ctx.arc(x + radius, y + TILE_SIZE - radius, radius, 0.5 * Math.PI, Math.PI);
                ctx.lineTo(x, y + radius);
                ctx.arc(x + radius, y + radius, radius, Math.PI, 1.5 * Math.PI);
                ctx.fill();
            });
        }

        /**
         * Updates the score display and runs the pulse animation.
         * @param {number} newScore The current score.
         */
        function updateScoreDisplay(newScore) {
            scoreDisplay.children[0].textContent = `üçé Score: ${newScore}`;
            // Simple animation on eating food
            scoreDisplay.children[0].classList.add('apple-pulse');
            setTimeout(() => {
                scoreDisplay.children[0].classList.remove('apple-pulse');
            }, 500);
        }

        // --- Game Logic ---

        /**
         * Checks if the snake has collided with the wall or itself.
         * @param {Object} head The new head position.
         * @returns {boolean} True if a collision occurred.
         */
        function checkCollision(head) {
            // Wall collision
            if (head.x < 0 || head.x >= GRID_SIZE || head.y < 0 || head.y >= GRID_SIZE) {
                return true;
            }

            // Self-collision (check head against all body segments)
            for (let i = 1; i < snake.length; i++) {
                if (head.x === snake[i].x && head.y === snake[i].y) {
                    return true;
                }
            }

            return false;
        }

        /**
         * Main game update logic, called every GAME_SPEED interval.
         */
        function updateGame() {
            if (isGameOver || isGamePaused) return;

            // Update direction with buffered input
            direction = nextDirection;

            // Calculate the new head position
            const newHead = {
                x: snake[0].x + direction.x,
                y: snake[0].y + direction.y
            };

            // Check for collisions
            if (checkCollision(newHead)) {
                gameOver();
                return;
            }

            // Add the new head to the snake
            snake.unshift(newHead);

            // Check if the snake ate the food
            if (newHead.x === food.x && newHead.y === food.y) {
                score++;
                updateScoreDisplay(score);
                // The snake grows by NOT removing the tail
                generateFood();
                
                // Play sound effect for eating 
                playAudio(eatSound); // Using robust playAudio function
            } else {
                // Remove the tail if no food was eaten
                snake.pop();
            }
            
            // Draw the new state
            draw();
        }

        /**
         * The main game animation loop using requestAnimationFrame.
         */
        function gameLoop(currentTime) {
            if (isGameOver || isGamePaused) {
                // If paused or over, stop the loop temporarily
                return;
            }

            gameLoopId = requestAnimationFrame(gameLoop);

            // Control game logic speed
            if (currentTime - lastMoveTime > GAME_SPEED) {
                lastMoveTime = currentTime;
                updateGame();
            }
        }
        
        /**
         * Shows the start screen overlay.
         * @param {string} title The title to display (e.g., "Start Game" or "Game Over!").
         * @param {boolean} showRestart If true, shows the restart button.
         * @param {number} finalScore If provided, displays the final score.
         */
        function showOverlay(title, showRestart, finalScore) {
            const restartButtonHTML = showRestart 
                ? `<button id="restartButton" class="restart-button">Restart Game</button>`
                : '';
            const scoreHTML = finalScore !== undefined
                ? `<p class="text-xl">Final Score: <span id="finalScore">${finalScore}</span></p>`
                : '';
            
            messageBox.innerHTML = `
                <h2 class="text-4xl font-extrabold mb-4">${title}</h2>
                ${scoreHTML}
                ${restartButtonHTML}
                <p class="text-lg mt-4 text-gray-400">${showRestart ? '' : 'Press ENTER or Click to Start'}</p>
            `;
            messageBox.classList.remove('hidden');

            // Re-attach event listener if the button was just created
            if (showRestart) {
                document.getElementById('restartButton').addEventListener('click', startGame);
            }
        }

        /**
         * Function to start the game after initial user interaction.
         */
        function startGame() {
            // 1. Reset logic and state
            resetGameLogic();

            // 2. Play music (This is the critical step for browser policy)
            // Background music should not be rewound if it's already playing, but since this
            // is called on start/restart, we'll ensure it plays and sets volume.
            bgMusic.volume = 1.0; // VOLUME set to 100%
            bgMusic.play().catch(e => {
                // Fallback for auto-play block, usually fixed by the user interaction check
                console.error("Background music playback blocked:", e);
            });


            // 3. Update state to running
            isGamePaused = false;
            messageBox.classList.add('hidden');
            gameStatus.textContent = "Use Arrow Keys";

            // 4. Start the animation loop
            if (gameLoopId) {
                cancelAnimationFrame(gameLoopId);
            }
            gameLoopId = requestAnimationFrame(gameLoop);
        }

        /**
         * Displays the game over message and stops the game.
         */
        function gameOver() {
            isGameOver = true;
            cancelAnimationFrame(gameLoopId);
            gameStatus.textContent = "Hit wall or yourself!";
            
            // Play game over sound
            playAudio(failSound); // Using robust playAudio function

            // Stop and rewind background music
            bgMusic.pause();
            bgMusic.currentTime = 0;

            // Show Game Over overlay
            showOverlay('Game Over!', true, score);
        }

        // --- Event Handlers ---

        /**
         * Handles key presses.
         */
        function handleKeydown(event) {
            if (isGameOver && (event.key === 'Enter' || event.key === ' ')) {
                // User pressed key to restart (handled by restart button logic in showOverlay)
                return; 
            }
            
            // If the game is paused (start screen), start it
            if (isGamePaused) {
                if (event.key === 'Enter' || event.key === ' ') {
                    startGame();
                    event.preventDefault();
                }
                return;
            }

            // Prevent snake from reversing immediately (e.g., going left when moving right)
            const newDir = { x: 0, y: 0 };
            
            switch (event.key) {
                case 'ArrowUp':
                    if (direction.y === 0) newDir.y = -1;
                    break;
                case 'ArrowDown':
                    if (direction.y === 0) newDir.y = 1;
                    break;
                case 'ArrowLeft':
                    if (direction.x === 0) newDir.x = -1;
                    break;
                case 'ArrowRight':
                    if (direction.x === 0) newDir.x = 1;
                    break;
                default:
                    return; // Ignore other keys
            }

            if (newDir.x !== 0 || newDir.y !== 0) {
                nextDirection = newDir;
                event.preventDefault(); // Stop scrolling the page
            }
        }
        
        /**
         * Handles click/tap interaction for starting the game.
         */
        function handleInteraction() {
            if (isGamePaused && !isGameOver) {
                startGame();
            }
        }


        // --- Initialization ---
        window.addEventListener('keydown', handleKeydown);
        canvas.addEventListener('click', handleInteraction);
        canvas.addEventListener('touchstart', handleInteraction); // Handle touch taps

        // Initial setup: Show the start screen and reset variables
        window.onload = () => {
            resetGameLogic();
            showOverlay('Snake Game', false); // Show start message
        };
    </script>
</body>
</html>
